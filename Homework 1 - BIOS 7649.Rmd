---
title: "Statistical Methods in Genomics - BIOS 7649 Homework 1"
author: "Dominic Adducci"
output: html_document
---

```{r}

library(tidyverse)
library(pwr)
library(kableExtra)

```

# Question 1

## Part A
Is it possible to avoid the effects of the experimental factors? 

No, it is not possible to avoid the effects of the experimental factors. Different confounding factors including time-of-day and stress from handling can have an effect on the expression of genes. Additionally, even between mice there can be large variation, and because most experiments are based on single samples from each subject (in this case mice) this variable is often impossible to correct for. 

## Part B
If not, how should we perform the modeling and interpret the reults in light of these effects?

\newpage

# Question 2

Background:

* A two-fold difference between the treated and untreated mice would correspond to a $\delta = 1$, assuming  a base 2 logarithm is used. 

* Recommended $\alpha$ and $\sigma$ values from *Design of DNA Microarray Experiment* will be used, which corresponds to $\alpha = 0.001$ and $\sigma = 0.5$ (when using base 2 logarithms). 

* Sample size equation is as follows:

$$n = \frac{4(z_{\alpha/2}+z_{\beta})^2}{(\delta/\sigma)^2}$$
Where $\alpha = 0.001$ fixes $z_{\alpha/2} = -3.29$. 

These steps are performed in the *pwr.t.test()* from the *pwr* package. 

```{r}

# Making a function to calculate sample size and cost for specific power level.
size_cost <- function(power_level){
  # power_level: Refers to the desired power level (will span 0.80 to 0.95).
  
  power_output <- pwr.t.test(n = NULL,d = 1,sig.level = 0.001,
                             power = power_level,type = "two.sample",
                             alternative = "two.sided")
  
  # Calculating the total sample size. n from output is the number in each
  # group, meaning we have to multiply by 2 for total sample size.
  sample_size <- ceiling(power_output$n) * 2
  
  cost <- 1000 * sample_size
  
  return(c(sample_size,cost))
  
}

```
```{r}

power_vector <- seq(0.80,0.95,by = 0.01) # Vector of different power levels.

# Calculating sample size and cost for various power levels. 
cost_size_matrix <- t(sapply(power_vector, function(x) size_cost(x)))

# Combining vector of power levels with cost and sample size results. 
cost_size_power <- data.frame(cbind(power_vector,cost_size_matrix))
colnames(cost_size_power) <- c("Power","Sample Size","Cost ($)")

cost_size_power_tbl <- kbl(cost_size_power,
                           caption = "Sample Size and Cost of Power Levels",
                           booktabs = TRUE, align = "lcc") %>%
  kable_styling(latex_options = "HOLD_position")

cost_size_power_tbl

```

Table 1 illustrates the relationship between increasing power and sample size and cost. Assumptions include that kidney gene expressions between the treated and non-treated mice will be compared by level of expression of each gene. The value $\delta = 1$ represents the difference in means for each gene, where in this study a base 2 logarithm is used meaning that $\delta = 1$ corresponds to a twofold difference in gene expression in the kidneys of treated and non-treated mice. The significance level, $\alpha$, is set at $\alpha = 0.001$ to limit the number of false discoveries. Power level varies from 0.80 to 0.95.

The null and alternative hypothesis for each gene are as follows:

$$H_0: \delta = 0$$
$$H_1: \delta \neq 0$$
The null hypthesis states that there is no meaningful difference between the mean expression of a particular gene, and the alterantive is that there is a significant difference between the mean expression of the gene is both groups. A two sample t-test was used as there are two different groups, treated and un-treated, and a two sided test was applied as expression for a particular gene may potentially be higher in either group. 20,000 probe sets corresponds to 20,000 genes, and with a significance level of 0.001 this mean an expected number of false positives is 20. R version 4.3.1 was used in this analysis, and sample size calculations were performed using the *pwr.t.test* function from the *pwr* package in R. 









