---
title: "Homework 5 - BIOS 7649"
author: "Dominic Adducci"
output: pdf_document
---

```{r, echo = F, include = F}

library(tidyverse)
library(RNASeqPower)
library(edgeR)
library(cqn)
library(kableExtra)
library(yeastRNASeq)
library(EDASeq)

pardefault <- par()

```

# Question 1 - Next Generation Sequencing: Sample Size Estimates

```{r, echo = F}

### START QUESTION 1 CODE ###

# Loading data into R environment.
data("montgomery.subset")

data("uCovar")

```

### Part A
Using **rnapower()**, recreate Figure 3 from the journal club paper using: Hart et al., (2013) "Calculating sample size estimates for RNA sequencing data." What does this figure show? 

```{r, echo = F}

## START QUESTION 1 PART A CODE ##

# Calculating sample size estimates using rnapower() function.
figure3_data <- data.frame(rnapower(depth = seq(1,50,by = 1), 
                                    cv = c(.4,0.8,1.2),effect = 2,
                                    alpha = 0.01, power = 0.8))

# Formatting the results, This includes turning data into long format,
# changing values for cv, and then converting depth and cv from character
# to numeric. 
colnames(figure3_data) <- c("cv0.4","cv0.8","cv1.2")

figure3_data <- rownames_to_column(figure3_data,"depth")

figure3_data_long <- pivot_longer(figure3_data,
                                  cols = starts_with("cv"),
                                  names_to = "cv",
                                  values_to = "sample_size")

figure3_data_long$cv <- replace(figure3_data_long$cv, 
                                figure3_data_long$cv == "cv0.4",0.4)

figure3_data_long$cv <- replace(figure3_data_long$cv,
                                figure3_data_long$cv == "cv0.8",0.8)

figure3_data_long$cv <- replace(figure3_data_long$cv,
                                figure3_data_long$cv == "cv1.2",1.2)

figure3_data_long <- figure3_data_long %>%
  mutate(depth = as.numeric(depth),
         cv = factor(cv))

# Plotting samples size estimates.
figure3_plot <- ggplot(figure3_data_long, aes(x = depth,
                                              y = sample_size,
                                              color = cv, shape = cv)) +
  geom_point() +
  geom_line() +
  scale_color_manual(values = c("black","red","green")) +
  scale_shape_manual(values = c(1,2,3)) +
  labs(title = "Sample Size Estimates",
       x = "Depth of Gene", y = "Samples Needed",
       legend = "CV") +
  theme_bw() +
  theme(legend.position = c(0.95,0.84))

figure3_plot

## FINISH QUESTION 1 PART A CODE ##

```

The above figure shows the sample size needed as the depth of gene increases from 1 to 50, and cv (coefficient of variation) varies between 0.4, 0.8, and 1.2. 

### Part B
For the Montgomery data, create a row in Table 1 in the Hart et al. paper. Note that genes that have zero counts in all 10 samples were already excluded, so "% mapped", will be 100%. How does the Montgomery data compare to the other data sets in Table 1? 

```{r, echo = F}

## START QUESTION 1 PART B CODE ##

# Making a DGEList from the Montgomery data. 
mgd_dgel <- DGEList(montgomery.subset)

# Calculating normal factors.
mgd_nf <- calcNormFactors(mgd_dgel)

# Calculating counts per million.
cpm_results <- cpm(mgd_nf)

# Initializing the ranges. 
cpg_cpm_range <- c(0,0.01,0.1,1,10,100,1000,Inf)

# Storing genes counts in a vector.
gene_counts <- vector("numeric", 7)

# Using a for loop to calculate the distribution of counts for each range.
for(i in 1:7){
  gene_counts[i] <- sum(rowSums(cpm_results >= cpg_cpm_range[i] & 
                                cpm_results < cpg_cpm_range[i + 1]) > 0)
}

# Calculating the average number of reads for each gene and then calculating
# the average counts in total. Lastly calculate counts per million. 
# Total library size serve as denominator. 
gene_average <- mean(rowMeans(mgd_dgel$counts))

library_size <- sum(mgd_dgel$samples$lib.size)

read_average <- (gene_average/library_size) * 1e6

table1_row <- data.frame(matrix(c(read_average,100,gene_counts),nrow = 1))

table1_row <- cbind("Montgomery Data",10,table1_row)

colnames(table1_row) <- c("Sample","n","Avg Reads","% Mapped","<0.01",
                          "0.01-0.1","0.1-1","1-10","10-100","100-10")

table1_tbl <- table1_row %>%
  kbl(caption = "Montgomery Data: Counts per Gene per Millions Reads Mapped",
      booktabs = TRUE) %>%
  kable_styling(latex_options = "HOLD_position")

## FINISH QUESTION 1 PART B CODE ##

```

### Part C
Calculate the biological coefficient of variations (CV) from the Montgomery human lymphoblastoid data (use the function **estimateTagwiseDisp()** in edgeR). Plot the histogram and empirical cdf (use **ecdf()** function) and report the median and 90% percentile. How do the CVs compare with the examples in the Hart et al., paper in Figure 2? 

The square root of the negative binomial dispersion is known as the biological coefficient of variation (BCV).

$$BCV = \sqrt{\phi_g}\,\,;\,\,where\,\,\phi_g = NB\,\,dispersion$$
Calculating this first involved estimating the common dispersion and then the tagwise dispersion. After this the tagwise dispersions can be extracted and plotted using both a histogram and a cumulative distribution plot. 

```{r, echo = F}

## START QUESTION 1 PART C CODE ##

# Calculating the biological coefficient of variation for the Montgomery data
# set. The estimateTagwiseDisp() function from edgeR is used. 

# First calculating common dispersion.
cd_md <- estimateCommonDisp(mgd_dgel)

# Calculating the tagwise dispersion.
twd_md <- estimateTagwiseDisp(cd_md)

# Creating a histogram for the squareroot of the tagwise dispersion values. 
twd_values <- sqrt(twd_md$tagwise.dispersion)

# Creating empirical CDF. 
twd_ecdf <- ecdf(twd_values)

hist(twd_values)
plot(ecdf(twd_values))
```

### Part D
Using **rnapower()**, recreate Figure 3 from Hart et al. again but with two curves using the median and the 90% percentile CV across genes for the Montgomery data. What sample size do you recommend?

```{r, echo = F}

## START QUESTION 1 PART D CODE ##

# Calculating median and 90th percentile cv across genes. 
twd_median <- quantile(twd_ecdf,0.5)
twd_nintieth <- quantile(twd_ecdf,0.9)

# Making a plot to show sample size using rnapower() function.
twd_rnapower <- data.frame(rnapower(depth = seq(1,50,by = 1),
                                    cv = c(twd_median,twd_nintieth),effect = 2,
                                    alpha = 0.01, power = 0.8))

# Formatting the results. This includes turning data into long format,
# changing value for cv, and then converting depth and cv from character
# to numeric.
colnames(twd_rnapower) <- c("cv0.5","cv0.9")

twd_rnapower <- rownames_to_column(twd_rnapower,"depth")

twd_rnapower_long <- pivot_longer(twd_rnapower,
                                  cols = starts_with("cv"),
                                  names_to = "cv",
                                  values_to = "sample_size")

twd_rnapower_long$cv <- replace(twd_rnapower_long$cv,
                                twd_rnapower_long$cv == "cv0.5",0.5)

twd_rnapower_long$cv <- replace(twd_rnapower_long$cv,
                                twd_rnapower_long$cv == "cv0.9",0.9)

twd_rnapower_long <- twd_rnapower_long %>%
  mutate(depth = as.numeric(depth),
         cv = factor(cv))

twd_ss_plot <- ggplot(twd_rnapower_long, aes(depth,
                                             y = sample_size,
                                             color = cv, shape = cv)) +
  geom_point() +
  geom_line() +
  scale_color_manual(values = c("black","red")) +
  scale_shape_manual(values = c(1,2)) +
  labs(title = "Sample Size Estimates",
       x = "Depth of Gene",y = "Samples Needed",
       legend = "CV") +
  theme_bw() +
  theme(legend.position = c(0.94,0.87))

twd_ss_plot

## FINISH QUESTION 1 PART D CODE ##

```


### Part E 
Using **rnapower()**, recreate the curve (not the histogram) in the top Figure 4 from the Hart et al., paper. If you cannot recreate the figure, please explain any differences. 



# Question 2 - Next Generation Sequencing: Pre-Processing

```{r, echo = F}

### START QUESTION 2 CODE ###

# Loading in yeast data. 
data(geneLevelData)
data(yeastGC)
data(yeastLength)

```

### Part A
Within **geneLevelData**, how many genes have all zeros as counts? How many have at least one sample with a zero? 

```{r, echo = F}

## START QUESTION 2 PART A CODE ##

# Finding number of genes with all zero counts. 
genes_all_zero <- geneLevelData %>%
  dplyr::filter(mut_1 == 0 & mut_2 == 0 & wt_1 == 0 & wt_2 == 0)

# Finding number of genes with at least one zero count.
gene_one_zero <- geneLevelData %>%
  dplyr::filter(mut_1 == 0 | mut_2 == 0 | wt_1 == 0 | wt_2 == 0)

# Cleaning data so that only genes with a total count of 10 between samples
# are included. 
geneLevelDataFilter <- geneLevelData %>%
  mutate(row_sums = rowSums(across(where(is.numeric)))) %>%
  filter(row_sums >= 10) %>%
  select(-row_sums)

# Creating a SeqExpressionSet
exprs = as.matrix(geneLevelDataFilter) # matrix of counts
sub = intersect(rownames(geneLevelDataFilter),names(yeastGC))
exprs = exprs[sub,] # only examine genes with annotated GC content/length
row.names(exprs) = NULL # remove row and column names
colnames(exprs) = NULL
# Create a SeqExpressionSet, which contains counts, labels for the samples and GC content/length
counts = newSeqExpressionSet(counts = exprs,
                             phenoData = AnnotatedDataFrame(data.frame(conditions = factor(c("mut","mut","wt","wt")),
                                                                       row.names = colnames(exprs))),
                             featureData = data.frame(gc = yeastGC[sub],
                                                      length = yeastLength[sub]))

## FINISH QUESTION 2 PART A CODE ##

```

* There are `r nrow(genes_all_zero)` genes that have all zero as counts. 
* There are `r nrow(gene_one_zero)` genes that have at least one zero count between the four different samples. 

### Part B
For the following plots, use the log scale. 

```{r, echo = F}

## START QUESTION 2 PART B CODE ##

# Making a boxplot for the counts.
EDASeq::boxplot(counts)
```

The above figure shows boxplots of the sample counts. Because a **SeqExpressionSet** was created the output from the boxplot should be on the log scale already. 

```{r, echo = F}

# Making a mean variance plot.
EDASeq::meanVarPlot(counts, log = TRUE)

```


```{r, echo = F}

# Assessing bias by GC content using a bias plot. 
EDASeq::biasPlot(counts,"gc",log = T)

```

```{r, echo = F}

# Assessing bias by length using a bias plot
EDASeq::biasPlot(counts,"length",log = T)

## FINISH QUESTION 2 PART B CODE ##

```

### Part C
Apply **withinLaneNormalization()** to normalize by GC content. See help file and try different methods for normalization with the "which" option. Describe the different methods. Use **biasPlot()** before and after normalization. How do the methods compare? Save the normalized results in a new object to use in the next part. 

```{r, echo = F}

## START QUESTION 2 PART C CODE ##

# Normalizing GC content using different methods. 

# Using loess method
loess_within <- withinLaneNormalization(counts,"gc",which = "loess")

EDASeq::biasPlot(loess_within,"gc",log = T)


```

```{r, echo = F}

# Using median method. 
median_within <- withinLaneNormalization(counts,"gc",which = "median")

EDASeq::biasPlot(median_within,"gc",log = T)

```

```{r, echo = F}

# Using upper method. 
upper_within <- withinLaneNormalization(counts,"gc",which = "upper")

EDASeq::biasPlot(upper_within,"gc",log = T)

```


```{r, echo = F}

# Using full method.
full_within <- withinLaneNormalization(counts,"gc",which = "full")

EDASeq::biasPlot(full_within,"gc",log = T)

## FINISH QUESTION 2 PART C CODE ##

```

### Part D
Using the within-lane normalized data from the previous part, apply **betweenLaneNormalization()** to normalize across samples. Try different methods for normalization with the "which" option. Describe the different methods. Use **boxplot()** before and after normalization. How do the methods compare? 

```{r, echo = F}

## START QUESTION 2 PART D CODE ##

# Using different between methods on the within loess method.
loess_between_median <- betweenLaneNormalization(loess_within,which = "median")
loess_between_upper <- betweenLaneNormalization(loess_within,which = "upper")
loess_between_full <- betweenLaneNormalization(loess_within,which = "full")

par(mfrow = c(1,2))

EDASeq::boxplot(loess_within)
EDASeq::boxplot(loess_between_median)
EDASeq::boxplot(loess_between_upper)
EDASeq::boxplot(loess_between_full)

```


```{r, echo = F}

# Using different between methods on the within median method. 
median_between_median <- betweenLaneNormalization(median_within,
                                                  which = "median")
median_between_upper <- betweenLaneNormalization(median_within,which = "upper")
median_between_full <- betweenLaneNormalization(median_within,which = "full")

par(mfrow = c(1,2))

EDASeq::boxplot(median_within)
EDASeq::boxplot(median_between_median)
EDASeq::boxplot(median_between_upper)
EDASeq::boxplot(median_between_full)

```


```{r, echo = F}

# Using different between methods on the within upper method.
upper_between_median <- betweenLaneNormalization(upper_within,which = "median")
upper_between_upper <- betweenLaneNormalization(upper_within,which = "upper")
upper_between_full <- betweenLaneNormalization(upper_within,which = "full")

par(mfrow = c(1,2))

EDASeq::boxplot(upper_within)
EDASeq::boxplot(upper_between_median)
EDASeq::boxplot(upper_between_upper)
EDASeq::boxplot(upper_between_full)

```

```{r, echo = F}

# Using different between methods on the within full method. 
full_between_median <- betweenLaneNormalization(full_within,which = "median")
full_between_upper <- betweenLaneNormalization(full_within,which = "upper")
full_between_full <- betweenLaneNormalization(full_within,which = "full")

par(mfrow = c(1,2))

EDASeq::boxplot(full_within)
EDASeq::boxplot(full_between_median)
EDASeq::boxplot(full_between_upper)
EDASeq::boxplot(full_between_full)

## FINISH QUESTION 2 PART D CODE ##

### FINISH QUESTION 2 CODE ###

```


\newpage

# CODE 

```{r, ref.label=knitr::all_labels(), echo=TRUE, eval=FALSE}
```
